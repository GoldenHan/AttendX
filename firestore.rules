
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to check user roles from the 'users' collection
    function isUserAuthenticated() {
      return request.auth != null;
    }

    // Helper function to get a user's role.
    // It checks for document existence before trying to access data.role.
    function getUserRole(userId) {
      let userDocPath = /databases/$(database)/documents/users/$(userId);
      if (exists(userDocPath)) {
        return get(userDocPath).data.role;
      }
      return null;
    }

    function isAdmin(userId) {
      return isUserAuthenticated() && getUserRole(userId) == 'admin';
    }

    function isTeacher(userId) {
      return isUserAuthenticated() && getUserRole(userId) == 'teacher';
    }

    function isSupervisor(userId) {
      return isUserAuthenticated() && getUserRole(userId) == 'supervisor';
    }

    function isCaja(userId) {
      return isUserAuthenticated() && getUserRole(userId) == 'caja';
    }

    function isStudent(userId) {
      return isUserAuthenticated() && getUserRole(userId) == 'student';
    }

    // Rules for 'users' collection (contains all user types including students, teachers, admins, etc.)
    match /users/{userId} {
      // Allow any authenticated user to read any individual user document.
      // This is primarily to ensure helper functions (isAdmin, isTeacher, etc.) can
      // always fetch the role of a user to evaluate other rules.
      // LISTING users is still restricted below.
      allow read: if isUserAuthenticated();

      // Listing users is restricted to admin, teachers, and supervisors.
      allow list: if isUserAuthenticated() &&
                    (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid));

      // Create:
      // 1. Admins can create any user.
      // 2. Users can self-register if the request indicates a student role and matches auth token.
      allow create: if isUserAuthenticated() && (
                      isAdmin(request.auth.uid) ||
                      (request.auth.uid == userId && request.resource.data.role == 'student' && request.resource.data.email == request.auth.token.email)
                    );

      // Update:
      // 1. Admins can update any user.
      // 2. Users can update specific "safe" fields on their own profile,
      //    and specifically manage their 'requiresPasswordChange' flag.
      function isOwner(docUserId) {
        return request.auth.uid == docUserId;
      }
      function isUpdatingOwnSafeFields() {
        // Define which fields a user can update on their own profile
        // Excludes critical fields like 'role', 'email' (for auth sync), 'username' (for auth sync).
        let allowedFields = ['name', 'phoneNumber', 'photoUrl', 'notes', 'age', 'gender', 'preferredShift', 'attendanceCode', 'sedeId'];
        let passwordChangeField = ['requiresPasswordChange'];
        let allAllowed = allowedFields.concat(passwordChangeField);

        let incomingData = request.resource.data;
        let existingData = resource.data;

        // Check that only allowed fields are being modified
        let onlyAllowedFieldsModified = incomingData.keys().hasOnly(allAllowed);

        // Special handling for 'requiresPasswordChange': can only be set from true to false by the user.
        let validPasswordChangeUpdate = true;
        if (incomingData.keys().hasAny(passwordChangeField)) {
            if (!(existingData.requiresPasswordChange == true && incomingData.requiresPasswordChange == false)) {
                 // If user is trying to change it from false to true, or to some other value, deny.
                 // Or if it's not present in existing data (shouldn't happen for this flag).
                 if (incomingData.requiresPasswordChange != existingData.requiresPasswordChange) {
                    validPasswordChangeUpdate = false;
                 }
            }
        }
        // Ensure email and username are not changed by non-admins
        let emailUnchanged = incomingData.email == existingData.email;
        let usernameUnchanged = incomingData.username == existingData.username;

        return isOwner(userId) && onlyAllowedFieldsModified && validPasswordChangeUpdate && emailUnchanged && usernameUnchanged;
      }
      allow update: if isUserAuthenticated() && (isAdmin(request.auth.uid) || isUpdatingOwnSafeFields());


      // Delete: Only admins can delete user documents.
      allow delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }

    // Rules for 'groups' collection
    match /groups/{groupId} {
      // Admins, teachers, supervisors, cashiers can read/list. Students too (e.g. to see their group).
      allow read, list: if isUserAuthenticated() &&
                          (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid) || isCaja(request.auth.uid) || isStudent(request.auth.uid));
      // Admins and supervisors can create/update groups.
      allow create, update: if isUserAuthenticated() &&
                              (isAdmin(request.auth.uid) || isSupervisor(request.auth.uid));
      allow delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }

    // Rules for 'sessions' collection
    match /sessions/{sessionId} {
      allow read, list: if isUserAuthenticated() &&
                          (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid) || isCaja(request.auth.uid) || isStudent(request.auth.uid));
      // Admins, teachers, supervisors can create/update sessions.
      allow create, update: if isUserAuthenticated() &&
                              (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid));
      allow delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }

    // Rules for 'attendanceRecords' collection
    match /attendanceRecords/{recordId} {
      // Admins, teachers, supervisors, cashiers can list. Students can read their own.
      allow list: if isUserAuthenticated() &&
                    (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid) || isCaja(request.auth.uid));
      allow read: if isUserAuthenticated() &&
                    (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid) || isCaja(request.auth.uid) ||
                     (isStudent(request.auth.uid) && resource.data.userId == request.auth.uid) );
      // Admins, teachers, supervisors, cashiers can create records.
      allow create: if isUserAuthenticated() &&
                      (isAdmin(request.auth.uid) || isTeacher(request.auth.uid) || isSupervisor(request.auth.uid) || isCaja(request.auth.uid));
      // Only admins can modify/delete records.
      allow update, delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }

    // Rules for 'appConfiguration' collection (e.g., gradingConfig)
    match /appConfiguration/{configId} {
      allow read: if isUserAuthenticated(); // All authenticated users can read config.
      allow write: if isUserAuthenticated() && isAdmin(request.auth.uid); // Only admins can change config.
    }

    // Rules for 'teacherAttendanceRecords' collection
    match /teacherAttendanceRecords/{recordId} {
        allow read, list: if isUserAuthenticated() && (isAdmin(request.auth.uid) || isSupervisor(request.auth.uid));
        // Admin dashboard logs this centrally
        allow create: if isUserAuthenticated() && (isAdmin(request.auth.uid));
        allow update, delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }

     // Rules for 'sedes' collection
    match /sedes/{sedeId} {
      allow read, list: if isUserAuthenticated() && (isAdmin(request.auth.uid) || isSupervisor(request.auth.uid) || isTeacher(request.auth.uid) || isCaja(request.auth.uid));
      allow create, update, delete: if isUserAuthenticated() && isAdmin(request.auth.uid);
    }
  }
}
